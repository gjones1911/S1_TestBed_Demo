from transformers import pipeline
import numpy as np


class InstructorBot:
    """Used to load and interact with a fine tuned LLM bot intended to generate work instructions"""

    potential_tasks = [
        'bent_shaft',
        'faulted_bearing',
        'eccentric_rotor',
        'looseness',
        'faulted_coupling',
        'angular_misalignment',
        'offset_misalignment',
        'resonance_beam',
        'imbalance',
        'baseline',
    ]

   

    
    def __init__(self, bot_path, name='Instructor', max_length=600, temp=1e-10, truncation=True, do_sample=False):
        self.name=name
        self.instructor=self.load_bot(bot_path)
        self.max_length=max_length
        self.temperature=temp
        self.truncation=truncation
        self.do_sample=do_sample

    def load_bot(self, hf_path):
        return pipeline("text-generation", model=hf_path)

    def respond(self, task_for_instruction):
        max_length = self.max_length
        truncation = self.truncation
        do_sample = self.do_sample
        response = self.instructor(task_for_instruction, max_length=max_length, truncation=truncation, do_sample=do_sample, 
                            pad_token_id=self.instructor.tokenizer.eos_token_id)
        response_txt = response[0]['generated_text'].split("..")[0] + "."
        return response_txt

    def generate_prompts_name(self, task, rng=False, selection=1):
        # print('taks: ', task)
        # print("\n")
        prompt1 = f"Task: {task}\n\n"
        prompt2 = f"Job: {task}\n\n"
        prompt3 = f"Motor Issue: {task}"
        prompt4 = f"Maintenace Task: {task}"
        prompt5 = f"Condition: {task}"
        prompt6 = f"The motor has the following issue: {task}"
        prompts = [prompt1, prompt2, prompt3, prompt4, prompt5, prompt6]
        if rng:
            prompt = np.random.choice(prompts, 1)[0]
        else:
            prompt = prompts[selection]
        return prompt

    def respond_to_task_query(self, task, rng=False, selection=1, ret_prompt=False):
        prompt = self.generate_prompts_name(task, rng, selection)
        response = self.respond(prompt)
        if ret_prompt:
            return response, prompt
        return response


    def generate_task_steps_str(self, instruc_dict, task, prompt):
        task_str = ""
        instructions = instruc_dict[task].split(". ")
        task_str += prompt + "\n"
        for step, instruction in enumerate(instructions):
            task_str += f"{step+1}) {instruction}"
            if step < len(instructions)-1:
                task_str += ".\n"
        return task_str

    def show_task_steps(self, instruc_dict, task, prompt=None, verbose=True):
        instructions = instruc_dict[task].split(". ")
        if prompt is not None:
            # print(prompt)
            task_str = prompt  + "\n"
        else:
            task_str = ""
        for step, instruction in enumerate(instructions):
            # print(instruction)
            task_str += f"{step+1}) {instruction}"
            if step < len(instructions)-1:
                task_str += ".\n"
            # print(task_str)
        return task_str
    
    def pred(self, task_list, work_instructions, prompt_selection=1, rng=False):
        # generates ground truth and predicted work instructions for evaluation
        
        gt, pred = [], []
        for task in task_list:
            
            # Generate a prompt to match that used by the bot
            prompt = self.generate_prompts_name(task, rng=False, selection=1)
           
            # get true respones
            gt.append(self.generate_task_steps_str(work_instructions, task=task, 
                                               prompt=prompt))
    
            # get predicted response
            pred.append(self.respond(prompt))
        return gt, pred


    def string_accuracy(self, g, p):
        # tracks how well ground truth (g) strings for work instructions
        # match up to the generated responses. The g strings are what was 
        # used to train the model, and thus if all went well, the strings 
        # generated by the bot should match almost perfectly. Teh score 
        # method just counts how many correct strings are generated and 
        # calculates the average.This method is pure equality check, later  
        # I need to work on something a little more granular for more 
        # complex instruction generation evaluation.
        scores = []
        for i,gi in zip(g,p):
            # if the match count it as so
            if i == gi:
                scores.append(1)
            # if not, score the generated response zero
            else:
                scores.append(0)
        return scores

    def evaluate(self, task_list, work_instructions, prompt_selection=1, rng=False):
        """Will return how accuratly the bot can generate the given work instructions.
           Arguments:
                      task_list: list, a list of the work instruction key words which for 
                                       this model consist of different types of faults that can 
                                       be applied to the S1 test bed. They are listed as an list 
                                       object for this class as potential tasks. 
               
              work_instructions: dict, key=task from task list, value=string for work instructions. 
                                       These work instructions should be the ones the bot was trained on.
              prompt_selection: int(0-9), can be ignored, not used if rng=True
                           
                           rng: bool, if true the model will generate more randomized preambles for the tasks to test the
                                      robustness of the prompting
         returns:
             list, double: list of binary values indicated if the generated and original strings matched, accuracy in %
               
        """
        true_intructions, generated_instructions = self.pred( task_list, work_instructions, prompt_selection, rng)
        scores = self.string_accuracy(true_intructions, generated_instructions)
        accuracy = 0
        accuracy = sum([score for score in scores])/len(scores)
        return scores, accuracy*100
        

################################################
###    Helper funcs
################################################

# just prints the work instructions for
# comparison to the generated text
def show_task_steps(instruc_dict, task, prompt, verbose=True):
    task_str = ""
    instructions = instruc_dict[task].split(". ")
    # print(f"{prompt}")
    task_str += prompt + "\n"
    for step, instruction in enumerate(instructions):
        task_str += f"{step+1}) {instruction}"
        if step < len(instructions)-1:
            task_str += ".\n"
        if verbose:
            print(f"{step+1}) {instruction}")
            # print(step+1, ") ", instruction )
    if verbose:
        print("-----------------------")
        print("-----------------------\n")
    return task_str

# lisint of potential issues
potential_tasks = ['bent_shaft','faulted_bearing','eccentric_rotor','looseness',
                   'faulted_coupling','angular_misalignment','offset_misalignment',
                   'resonance_beam','imbalance','baseline',]

potential_tasks_dict_id_type = {i: s for i,s in enumerate(potential_tasks)}

potential_tasks_dict_type_id = {v: k for k,v in potential_tasks_dict_id_type.items()}
taskID_dict = potential_tasks_dict_id_type

taskName_dict = potential_tasks_dict_type_id

def show_task_options():
    for s in potential_tasks:
        print(f'"{s}"')

def show_name_id_pairs():
    print("\n\t\tFrom: taskName_dict\n")
    print("\t\t Using: generate_prompts(idx, rng=False, selection=1)")
    for n,id in taskName_dict.items():
        print(f"Task:'{n}', ID: {id}")

def show_id_name_pairs():
    print("\n\t\tFrom: taskID_dict\n")
    for n,id in taskID_dict.items():
        print(f"Task:'{n}', ID: {id}")

def generate_prompts_id(idx, rng=False, selection=1):
    prompt1 = f"Task: {potential_tasks[idx]}\n\n"
    prompt2 = f"Job: {potential_tasks[idx]}\n\n"
    prompt3 = f"Motor Issue: {potential_tasks[idx]}"
    prompt4 = f"Maintenace Task: {potential_tasks[idx]}"
    prompt5 = f"Condition: {potential_tasks[idx]}"
    prompt6 = f"The motor has the following issue: {potential_tasks[idx]}"
    prompts = [prompt1, prompt2, prompt3, prompt4, prompt5, prompt6]
    if rng:
        prompt = np.random.choice(prompts, 1)[0]
    else:
        prompt = prompts[selection]
    return prompt

def generate_prompts_name(task, rng=False, selection=1):
    # print('taks: ', task)
    # print("\n")
    prompt1 = f"Task: {task}\n\n"
    prompt2 = f"Job: {task}\n\n"
    prompt3 = f"Motor Issue: {task}"
    prompt4 = f"Maintenace Task: {task}"
    prompt5 = f"Condition: {task}"
    prompt6 = f"The motor has the following issue: {task}"
    prompts = [prompt1, prompt2, prompt3, prompt4, prompt5, prompt6]
    if rng:
        prompt = np.random.choice(prompts, 1)[0]
    else:
        prompt = prompts[selection]
    return prompt




# issue: work instruction list
work_instructions = {'bent_shaft': 'Remove the top section of both bearing pedestals taking care to save the 0.003 shims installed in the bearing housing. Then loosen the coupling set screw on the rotor shaft side of the coupling. Lift the rotor shaft assembly of the MVAT assembly and pull the shaft out of the coupling. Then loosen the bearing and rotor set screws and install them on the new rotor shaft. Re-install the rotor assembly with the new shaft. Be sure to install the 0.003 shims.',
                'faulted_bearing': 'Remove the top section of both bearing pedestals taking care ot save the 3/8x2" shims installed in the bearing housing. Then loosen the coupling set screw on the rotor shaft side of the coupling. Lift the rotor shaft assembly of the MVAT assembly and pull the shaft out of the coupling. Then loosen the bearing set screws and replace the faulted bearing set with the new bearing set. Re-install the rotor assembly with the new bearing set assembly. Be sure to re-install the shims.',
                'eccentric_rotor' : 'Remove the top section of both bearing pedestals taking care to save the 0.003 shims installed in the bearing housing. Then loosen the coupling set screw on the rotor shaft side of the coupling. Lift the rotor shaft assembly of the MVAT assembly and pull the shaft out of the coupling. Then loosen the outer bearing and rotor set screws and remove them from the rotor shaft. Install the new rotor in place of the eccentric rotor and re-install the outer bearing. Re-install the rotor assembly. Be sure to install the 0.003 shims.',
                'looseness': 'Tighten the hold-down bolts on the two bearing pedestal mounted on the rotor base plate.',
                'faulted_coupling': 'Remove the top section of both bearing pedestals taking care to save the 0.003 shims installed in the bearing housing. Then loosen the coupling set screws on the coupling. Lift the rotor shaft assembly of the MVAT assembly and pull the shaft out of the coupling. Then replace the faulted coupling with the new coupling. Re-install the rotor assembly with the new coupling. Be sure to install the 0.003 shims.',
                'angular_misalignment': 'Loosen the coupling set screw on the motor shaft side of the coupling. Remove the motor from the motor pedestal on the left side of the MVAT. Remove the lift(s) from the motor pedestal. Re-install the motor on the motor pedestal. Be sure that the motor and rotor shafts are aligned.',
                'offset_misalignment': 'Loosen the coupling set screw on the motor shaft side of the coupling. Remove the motor from the motor pedestal on the left side of the MVAT. Remove the lift(s) from the motor pedestal. Re-install the motor on the motor pedestal. Be sure that the motor and rotor shafts are aligned.',
                'resonance_beam': 'Remove the resonance beam from the MVAT assembly. The beam is mounted on the back side fo the right bearing pedestal.',
                'imbalance': 'Remove the top section of both bearing pedestals taking care to save the 0.003 shims installed in the bearing housing. Then loosen the coupling set screw on the rotor shaft side of the coupling. Lift the rotor shaft assembly of the MVAT assembly and pull the shaft out of the coupling. Then loosen the outer bearing and rotor set screws and remove them from the rotor shaft. Remove the trim weights from the rotor and re-install the rotor assembly. Be sure to install the 0.003 shims.',
                'baseline': 'Operable condition, no action required.'}

